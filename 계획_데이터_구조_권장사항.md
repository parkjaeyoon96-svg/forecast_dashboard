# 📊 계획 데이터 구조 권장사항

## 🔍 현재 상황

- **입력**: 브랜드별 파일 (`202511R_M.csv`, `202511R_MLB.csv`, ...)
- **현재 처리**: 모든 브랜드를 하나의 파일로 통합 (`plan_202511_전처리완료.csv`)
- **대시보드 사용**: 브랜드별 필터링/조회 필요

---

## 📋 옵션 비교

### 옵션 1: 통합 파일 (현재 방식) ✅ **권장**

```
raw/202511/plan/plan_202511_전처리완료.csv
```

**구조:**
```csv
브랜드,구분,백화점,면세점,...,전체
M,TAG가 [v+],9348281,10918718,...,42997751
M,실판매액 [v+],8970000,10600000,...,...
MLB,TAG가 [v+],...,...
MLB,실판매액 [v+],...,...
```

#### ✅ 장점
1. **한 번에 모든 브랜드 조회 가능**
   - 전체 집계/비교 분석 용이
   - 브랜드 간 비교 쿼리 단순

2. **파일 관리 단순**
   - 한 파일만 관리
   - 버전 관리 용이

3. **대시보드 로딩 효율**
   - 한 번만 로드하면 모든 브랜드 사용 가능
   - 브랜드 필터링은 코드에서 처리

4. **데이터 일관성**
   - 모든 브랜드가 동일한 구조/포맷
   - 전처리 로직 일관성 유지

5. **확장성**
   - 새 브랜드 추가 시 자동 통합
   - 브랜드 수가 많아져도 관리 용이

#### ⚠️ 단점
1. **파일 크기**
   - 브랜드가 많으면 파일이 커짐 (하지만 CSV라서 큰 문제 없음)

2. **부분 업데이트 불가**
   - 한 브랜드만 수정해도 전체 재생성 필요

---

### 옵션 2: 브랜드별 분리 파일

```
raw/202511/plan/
├── plan_202511_M_전처리완료.csv
├── plan_202511_MLB_전처리완료.csv
├── plan_202511_MLB_KIDS_전처리완료.csv
└── ...
```

**구조 (각 파일):**
```csv
브랜드,구분,백화점,면세점,...,전체
M,TAG가 [v+],9348281,10918718,...,42997751
M,실판매액 [v+],8970000,10600000,...,...
```

#### ✅ 장점
1. **독립적 관리**
   - 브랜드별로 독립 업데이트 가능
   - 특정 브랜드만 수정/재생성 가능

2. **파일 크기 작음**
   - 브랜드별로 작은 파일
   - 메모리 사용량 적음

3. **권한 관리**
   - 브랜드별 접근 권한 분리 가능 (향후)

4. **병렬 처리**
   - 브랜드별 병렬 전처리 가능

#### ⚠️ 단점
1. **파일 관리 복잡**
   - 여러 파일 관리 필요
   - 브랜드 추가/삭제 시 파일 관리 복잡

2. **전체 집계 복잡**
   - 모든 브랜드 조회 시 여러 파일 로드 필요
   - 브랜드 간 비교 분석 복잡

3. **대시보드 로딩 복잡**
   - 필요한 브랜드 파일만 동적 로드 필요
   - 브랜드 전환 시 추가 로딩 필요

4. **데이터 일관성**
   - 브랜드별 파일 포맷 불일치 가능성
   - 전처리 로직 분산

---

## 💡 권장사항: **통합 파일 (옵션 1)** ✅

### 이유

1. **대시보드 사용 패턴**
   - 대시보드는 보통 여러 브랜드를 동시에 비교/분석
   - 브랜드별 필터링은 코드에서 처리 가능

2. **데이터 특성**
   - 계획 데이터는 월별로 한 번 생성
   - 부분 업데이트 빈도가 낮음

3. **유지보수성**
   - 한 파일 관리로 단순
   - 버전 관리 및 백업 용이

4. **확장성**
   - 브랜드 수 증가에 유연
   - 새 브랜드 추가 시 자동 통합

5. **성능**
   - 한 번 로드로 모든 브랜드 사용
   - 브랜드 필터링은 메모리에서 처리 (빠름)

---

## 🔧 구현 예시

### 현재 방식 (통합 파일) - 유지 권장

```python
# scripts/process_202511R_plan.py
def process():
    # ... (기존 코드) ...
    
    # 모든 브랜드를 하나의 DataFrame으로 통합
    res_df = pd.DataFrame(result_rows)
    # 브랜드 컬럼으로 필터링 가능
    # res_df[res_df['브랜드'] == 'M']  # MLB만
    # res_df[res_df['브랜드'] == 'MLB']  # MLB만
    
    # 저장: raw/202511/plan/plan_202511_전처리완료.csv
    output_path = get_plan_file_path(year_month)
    res_df.to_csv(output_path, index=False, encoding="utf-8-sig")
```

### 대시보드에서 사용

```typescript
// 브랜드별 필터링
const planData = await loadCSV('raw/202511/plan/plan_202511_전처리완료.csv');
const mlbPlan = planData.filter(row => row.브랜드 === 'M');
const mlbKidsPlan = planData.filter(row => row.브랜드 === 'MLB_KIDS');

// 전체 집계
const totalPlan = planData.reduce((sum, row) => sum + row.전체, 0);
```

---

## 🔄 대안: 하이브리드 방식 (선택사항)

만약 브랜드별 독립 관리가 정말 필요하다면:

```
raw/202511/plan/
├── plan_202511_전처리완료.csv      # 통합 파일 (주 파일)
└── by_brand/
    ├── plan_202511_M_전처리완료.csv
    ├── plan_202511_MLB_전처리완료.csv
    └── ...
```

- 통합 파일: 대시보드에서 주로 사용
- 브랜드별 파일: 필요 시 개별 사용

하지만 이 방식은 **복잡도만 증가**시키므로 권장하지 않습니다.

---

## 📝 최종 결론

**✅ 통합 파일 방식 유지 권장**

- 현재 구조가 이미 최적화되어 있음
- 대시보드 사용 패턴에 적합
- 유지보수 및 확장성 우수
- 브랜드별 필터링은 코드에서 쉽게 처리 가능

**변경이 필요한 경우:**
- 브랜드별 독립 권한 관리가 필수인 경우
- 브랜드 수가 매우 많아서 (50개 이상) 파일 크기가 문제인 경우
- 브랜드별 부분 업데이트가 매우 빈번한 경우

현재 상황에서는 **통합 파일 방식이 가장 적합**합니다.



